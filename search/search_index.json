{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Neurograph","text":"<p>Neurograph is a graph deep learning library. This library is still in the early phases of development and will evolve over time. This can be thought of as a toy project for combining concepts from graph theory and deep learning.</p>"},{"location":"#purpose","title":"Purpose","text":"<ul> <li>Experiment and research algorithms in graph theory and understand it's applications</li> <li>Tie concepts from graph theory to deep learning</li> <li>Data manipulation tool that utilize graph representations</li> <li>Invent a new graph neural network architecture</li> <li>Framework to visualize graphs</li> </ul>"},{"location":"data-extraction/feature-extraction/","title":"Feature Extraction","text":"<ul> <li>Feature Extraction<ul> <li>Community Based</li> </ul> </li> </ul>"},{"location":"data-extraction/feature-extraction/#feature-community-detection","title":"Feature Community Detection","text":"<ul> <li>Randomly detecting communities in graphs for feature extraction</li> <li>Triggers based on user specified queries?</li> </ul> <p>```mermaid flowchart LR A[Load Graph] --&gt; B[Community Detection] --&gt; C[Extract Features] A[Load Graph] &lt;--&gt; D[Reorder Nodes] D[Reorder Nodes] &lt;--&gt; C[Extract Features]</p> <p>```</p>"},{"location":"data-extraction/feature-extraction/#community-feature-extraction","title":"Community Feature Extraction","text":"<ul> <li>Input a comma separated flat file, load into data frame</li> <li>Extract all the headers of that file</li> <li>Create permutations for all combinations of headers in the file<ul> <li>Store the permutations in an array of sets</li> <li>Each permutation are headers used to create a temporary graph</li> </ul> </li> <li>For each graph created from a permutation<ul> <li>Run the community detection algorithm on the graph</li> <li>Count the amount of communities</li> <li>Get the average size of the communities</li> </ul> </li> <li>Select the headers that create a graph with the largest communities</li> <li>Return a list of headers that the user should use for data investigation</li> </ul>"},{"location":"data-extraction/feature-extraction/#correlation-matrix","title":"Correlation Matrix","text":"<ul> <li>Input comma separated flat file, load into data frame</li> <li>Extract the headers of the of the data frame</li> <li>Calculate correlation coefficient</li> </ul>"},{"location":"data-extraction/graph-markup-language/","title":"Graph Markup Language","text":"<ul> <li>Create graphs using configuration files </li> <li>Define a regular expression that represents the graph markup language</li> <li>Allow external database tools to ingest graph configuration files</li> </ul>"},{"location":"data-extraction/graph-markup-language/#adjacency-list-markup-labels-only","title":"Adjacency List Markup (Labels Only)","text":"<pre><code>\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\")\n\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\", \"&lt;NODE_2&gt;\")\n\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\")\n\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\")\n</code></pre> <ul> <li>This would be a config if you want to sort by label name</li> <li>Should except multi line comments with this syntax: <code>/* commment */</code></li> <li>Regular expression contains the following for each line<ul> <li>A node is defined by having it's label followed by a colon</li> <li>List of neighbors are surrounded by parenthesis</li> <li>Each element is surrounded by quotations</li> <li>Each element is separated by commas <pre><code>[ID, \"NODE_2\"]: ([ID, \"&lt;NODE_1&gt;\"], [ID, \"&lt;NODE_1&gt;\"])\n\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\", \"&lt;NODE_2&gt;\")\n\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\")\n\"NODE_1\": (\"&lt;NODE_1&gt;\", \"&lt;NODE_1&gt;\")\n</code></pre></li> </ul> </li> </ul>"},{"location":"data-extraction/graph-markup-language/#matrix-markup","title":"Matrix Markup","text":"<pre><code>rows: &lt;NUMBER&gt;\ncols: &lt;NUMBER&gt;\n\n&lt;INT&gt;,&lt;INT&gt;,&lt;INT&gt;\n&lt;INT&gt;,&lt;INT&gt;,&lt;INT&gt;\n&lt;INT&gt;,&lt;INT&gt;,&lt;INT&gt;\n</code></pre> <ul> <li>Two regular expressions will be defined since not all lines are the same</li> <li>The first regular expression will follow this pattern<ul> <li>The rows/cols variable will be defined and have a colon after it</li> <li>The next line can take in any digit except 0</li> </ul> </li> <li>The second regular expression is for the matrix values<ul> <li>Each line is separated by comma values</li> <li>Each element must be a series of digits</li> </ul> </li> </ul>"},{"location":"data-extraction/graph-markup-language/#adjacency-list-markup","title":"Adjacency List Markup","text":"<pre><code>[0,\"B\"]: ([1,\"A\",0],[2,\"C\",0])\n[1,\"A\"]: ([0,\"B\",0],[2,\"C\",0],[3,\"D\",0])\n[2,\"C\"]: ([1,\"A\",0],[0,\"B\",0],[4,\"E\",0])\n[3,\"D\"]: ([1,\"A\",0])\n[4,\"E\"]: ([2,\"C\",0])\n</code></pre> <ul> <li>Weights and id's of nodes are now include in config file</li> <li>id is included so calling methods to get unique nodes is not needed</li> <li>Regular expression is defined with the following criteria</li> <li>Extract integer values or any thing with quotes in between it</li> </ul>"},{"location":"data-extraction/language-data/","title":"Language Data","text":"<ul> <li>Convert raw text data to knowledge graphs </li> <li>Nodes in graphs are nouns (people, places, things)</li> <li>Edges in the graph are action words (Adjectives)</li> </ul>"},{"location":"data-extraction/language-data/#knowledge-graph-interpretation","title":"Knowledge Graph Interpretation","text":"<ul> <li>Data inputs can ether be a raw text file or comma separated file</li> <li>If the input is a csv file, load it to data frame and choose text column</li> <li>If it's a raw text file, load the data into a buffer</li> </ul>"},{"location":"data-extraction/language-data/#regular-expression","title":"Regular Expression","text":"<ul> <li>Word extraction: Split by spaces in characters</li> <li>Sentence Extraction: Split the characters by periods or commas</li> <li>For paragraphs, choose a specific amount of sentences to extract from expression</li> </ul>"},{"location":"data-extraction/language-data/#word-frequency","title":"Word Frequency","text":"<ul> <li>Extract a corpus of text</li> <li>Iterate through the corpus and store the frequencies of the words that occur</li> <li>Occurrences should be stored in hash map data structure</li> </ul>"},{"location":"data-extraction/regular-expressions/","title":"Regular Expressions","text":"<ul> <li>Critical needed component for data extraction and manipulation</li> <li>Will be used to create our graph markup language</li> <li>Expressions are needed for parsing delimiter file formats and custom languages</li> </ul>"},{"location":"data-extraction/regular-expressions/#match-single","title":"Match Single","text":"<ul> <li>Provide character buffer and regular expression pattern</li> <li>Compile the regular expression and check for errors</li> <li>iterate through the character buffer with the match pattern</li> <li>Allocate space for end and start match</li> <li>Gather the token results from the end and start match</li> <li>Add the token to the array based set</li> <li>Add the end match to the buffer (pointer arithmetic)</li> <li>Compare the match with another sub string</li> <li>If the compare is true, break out of the loop</li> </ul>"},{"location":"data-extraction/regular-expressions/#replace-character","title":"Replace Character","text":"<ul> <li>Provide a buffer, the string and the portion to replace (with regex pattern)</li> <li>Set string equal to character pointer</li> <li>Start with a do statement, within the statement</li> <li>while the character pointer is equal to the character to remove</li> <li>Increment the character pointer  (arithmetic)</li> <li><code>while(*test_string++ = *d++)</code></li> </ul>"},{"location":"data-structures/adjacency-list/","title":"Adjacency List","text":"<ul> <li>Used for representing connections in a graph </li> <li>Makes use of linked lists and standard arrays</li> </ul> Field Name Description <code>v</code> Amount of vertices in graph <code>e</code> Number of edges in graph <code>visited</code> Array of indices corresponding to visited nodes <code>directed</code> Flag to add directed relationships to graph nodes <code>err</code> Status for adjacency list <code>items</code> Node list that takes in inherited node types"},{"location":"data-structures/adjacency-list/#initialize","title":"Initialize","text":"<ul> <li>Create instance of adjacency list structure</li> <li>Allocate edges, visited, used and items arrays to the size of the vertices</li> <li>Set directed, error status and the vertice and edge counts</li> <li>Allocate the node lists, size is the amount of vertices</li> <li>Allocate edge list, size is the amount of edges</li> <li>Iterate for the amount of vertices set in the graph, set used and visited to 0</li> <li>Return instance of adjacency list</li> </ul>"},{"location":"data-structures/adjacency-list/#add-node","title":"Add Node","text":"<ul> <li>Take in src and destination with their respective ID's and weights</li> <li>Create a null node called \"check\" to assign temp node values</li> <li>Create a new node instance for the destination node</li> <li>Mark the first \"used\" slot as 1 with the destination ID as the index</li> <li>Check if source id head in node list is null</li> <li>If it is, set the new node instance next pointer to the source id head pointer</li> <li>Otherwise, set the src id head pointer to the temp check node</li> <li>Iterate through the linked list using check pointer</li> <li>Once the end of the list is reached, set the new node instance to the check node</li> <li>For non directed, same steps but create new instance for source and </li> <li>iterate with dst pointer instead of src_id for check pointer</li> </ul>"},{"location":"data-structures/adjacency-list/#get-node-by-id","title":"Get Node By Id","text":"<ul> <li>Provide adjacency list instance and id to search for</li> <li>Iterate through each vertex in the graph</li> <li>Grab the head of the vertex node list</li> <li>Iterate through the linked list until the head id matches the item to search for</li> <li>return the head id</li> <li>If no search_id is found, return blank node instance</li> </ul>"},{"location":"data-structures/adjacency-list/#transpose-items","title":"Transpose Items","text":"<ul> <li>Provide in adjacency list and adjacency list instance to reverse</li> <li>Iterate through the vertices in the graph</li> <li>Grab the head for each vertex index</li> <li>Go through each neighbor by looping in the linked list</li> <li>Grab the src node by searching for the node id with the head id as a parameter</li> <li>Grab the dst node by searching the node id with the vertex index as a parameter</li> <li>Add the relationship, head id is src id and i is destination id</li> <li>Return reverse instance of the adjacency list</li> </ul>"},{"location":"data-structures/adjacency-list/#resize-list","title":"Resize List","text":"<ul> <li>Provide adjacency list instance and new size</li> <li>Set the vertices and edge count in graph instance to the new size</li> <li>Reallocate the edges array to the new size</li> <li>Reallocate the items array to the new size</li> </ul>"},{"location":"data-structures/adjacency-list/#print-items","title":"Print Items","text":"<ul> <li>Iterate through the vertices in the graph</li> <li>Print out each vertex before printing it's neighbors</li> <li>Grab the head for each vertex index</li> <li>Go through each neighbor by looping in the linked list</li> <li>Print out each item in the linked list</li> </ul>"},{"location":"data-structures/adjacency-matrix/","title":"Adjacency Matrix","text":"<ul> <li>Methods for creating a matrix based graph</li> <li>Uses the regular matrix structure with set data structure</li> <li>Has the same methods as adjacency list with different implementation</li> </ul> Field Name Description V Amount of vertices in graph E Number of edges Visited Array of indices corresponding to visited nodes Used Amount of array slots used in the matrix Err Status flag for adjacency matrix Weights Matrix that stores the weights of the relationships in graph items Set data structure containing nodes of graph"},{"location":"data-structures/adjacency-matrix/#initialize","title":"Initialize","text":"<ul> <li>Create instance of adjacency list structure</li> <li>Allocate edges, visited, used and items arrays to the size of the vertices</li> <li>Set directed, error status and the vertice and edge counts</li> <li>Allocate the node lists, size is the amount of vertices</li> <li>Allocate edge list, size is the amount of edges</li> <li>Iterate for the amount of vertices set in the graph, set used and visited to 0</li> </ul>"},{"location":"data-structures/adjacency-matrix/#add-node","title":"Add Node","text":"<ul> <li>Provide set data structure instance, source and destination with their id's and weight</li> <li>Keep track of the source</li> <li>Get the directed and non directed index</li> <li>Directed index is source id times the number of vertices plus destination id</li> <li>Non directed is destination id times vertices plus source id</li> <li>If the graph is directed<ul> <li>Add destination item to the directed index of the items array</li> <li>Set the weight matrix to the weight value using the directed index</li> </ul> </li> <li>In the case that the graph is not directed<ul> <li>Set the set items to both the non directed and directed index with src and dst</li> <li>Set the weight matrix to the non directed and directed matrix with weight value</li> </ul> </li> </ul>"},{"location":"data-structures/node/","title":"Node","text":"<ul> <li>Module for representing generic nodes in a graph</li> <li>Multiple node types can be inherited with this new implementation</li> <li>Base node attribute will contain the id for mapping to adjacency list index</li> </ul>"},{"location":"data-structures/node/#node-type","title":"Node Type","text":"Attribute Description <code>node</code> General node value structure for testing graph algorithms <code>variable</code> Variable structure for creating computation graphs <ul> <li>Structure used for storing all generic types that a node can have</li> <li>Any potential structure that will be part of a graph can go here</li> </ul>"},{"location":"data-structures/node/#node_1","title":"Node","text":"Attribute Description <code>id</code> Numerical Identifier for node object <code>node_type</code> Structure that refers to generic node types <code>next</code> Pointer to next node for adjacency list representation <code>left</code> Left pointer for set implementation <code>right</code> Right pointer for set implementation <ul> <li>General node structure that will be used for all graph representations</li> <li>Temporarily used for representing data structure values</li> </ul>"},{"location":"data-structures/node/#node-value","title":"Node Value","text":"Attribute Description <code>weight</code> Weight value to represent how close nodes are to eachother <code>counter</code> Used in certain algorithms for counting amount of times a node was visited <code>label</code> Used for identifying a node by character label instead of id <ul> <li>This node value is used for general graph algorithms and demonstration purpose</li> <li>The node value structure is the default for testing out graph algorithms</li> <li>It inherits the base node type</li> </ul>"},{"location":"data-structures/node/#variable","title":"Variable","text":"Attribute Description <code>label</code> Name of operation being performed on inputs <code>output</code> Generic value stored with variable structure <code>upstream_value</code> Gradients passed backward from other nodes <code>forward</code> Operation to perform on inputs during forward pass <code>backward</code> Operation to perform on inputs during backward pass <code>inputs</code> Amount of inputs if the variable is also an operation <ul> <li>This structure is meant for creating nodes in a computation graph</li> <li>Each variable node uses it's neighbors as inputs</li> </ul>"},{"location":"data-structures/node/#edge","title":"Edge","text":"Attribute Description <code>src</code> Source node value <code>dst</code> Destination node value <code>weight</code> Weight that represents how closely related the nodes are <ul> <li>This is used for some searching/path finding</li> </ul>"},{"location":"graph-algorithms/centrality/","title":"Centrality","text":"<ul> <li>Algorithms for detecting clusters/communities</li> <li>Good utility for feature extraction for datasets</li> </ul>"},{"location":"graph-algorithms/centrality/#degree-centrality","title":"Degree Centrality","text":"<ul> <li>Count the amount of neighbors for each node</li> <li>Return a list of neighbor counts</li> <li>Return value from list with the highest amount of neighbors</li> </ul>"},{"location":"graph-algorithms/centrality/#closeness-centrality","title":"Closeness Centrality","text":"<ul> <li>Provide vertex for finding closeness centrality</li> <li>Initialize a sum to 0</li> <li>Iterate through each vertex in the graph</li> <li>Get the shortest path from the current node and the vertex provided</li> <li>Add the result of the shortest path to the sum</li> <li>Return value equal to $1/sum$ where sum is the original initlaized value</li> </ul>"},{"location":"graph-algorithms/community-detection/","title":"Community Detection","text":"<ul> <li>Algorithms for detecting clusters in graphs</li> <li>Utility for feature extraction built off these algorithms</li> </ul>"},{"location":"graph-algorithms/community-detection/#kosaraju","title":"Kosaraju","text":"<ul> <li>Perform depth first search on adjacency list graph<ul> <li>Push depth first search results to a queue</li> </ul> </li> <li>Transpose the graph based on the depth first search results</li> <li>Perform depth first search on the transposed graph<ul> <li>Push depth first search results to a queue</li> </ul> </li> <li>Mark all the transpose nodes as un-visited </li> <li>Allocate space for community results</li> <li>Iterate through queue while it's not empty<ul> <li>Grab item from the front of the queue and remove it</li> <li>If the transpose item was not visited</li> <li>Perform a depth first search and store results in a temp queue</li> <li>Get the results from the queue and add it to communities result</li> </ul> </li> </ul>"},{"location":"graph-algorithms/community-detection/#label-propagation","title":"Label Propagation","text":"<ul> <li>Perform a depth first search on the graph</li> <li>Export the node order from the depth first search to a queue</li> <li>Go through each node for the results in the queue<ul> <li>Get each nodes neighbors with it's labels</li> <li>Add the label and it's the amount of times it was inserted to a unique set</li> </ul> </li> <li>Choose the label where it has the highest insert count on the set</li> <li>Assign the current the node with the highest occurring label</li> </ul>"},{"location":"graph-algorithms/community-detection/#triangle-count-clustering-coefficient","title":"Triangle Count Clustering Coefficient","text":"<ul> <li>Triangle - Set of three nodes where each node has a relationship to all nodes</li> <li>Clustering coefficient can be found by the following steps<ul> <li>Multiplying the number of triangles passing through the node by two</li> <li>Dividing that number by the maximum number of relationships in the group</li> </ul> </li> </ul>"},{"location":"graph-algorithms/pathfinding/","title":"Pathfinding","text":"<ul> <li>Set of pathfinding algorithms to search graphs</li> <li>Store output results in data frames</li> <li>Control rate of search within graph</li> </ul>"},{"location":"graph-algorithms/pathfinding/#shortest-path","title":"Shortest Path","text":"<ul> <li>Initialize the following variable trackers<ul> <li>head node of the adjacency list for the graph</li> <li>distances - array of distances</li> <li>previous - array of previous distances</li> <li>queue - queue to store node values</li> </ul> </li> <li>Iterate for the amount of vertices in graph<ul> <li>If the current iteration is not equal to the start vertex, initialize<ul> <li>previous - Max integer</li> <li>distances - Max Integer</li> </ul> </li> </ul> </li> <li>Push start vertex to the front of the queue</li> <li>Mark first item of distances as 0 </li> <li>Iterate through queue while it's not empty<ul> <li>Get the first item of the queue (at the front)<ul> <li>Initilaize this value to u</li> </ul> </li> <li>Remove it from the queue</li> <li>Grab the head of the current item, index by u</li> <li>Iterate through the neighbors of the head node<ul> <li>if the distance with the head index is greater than the distance with the u index plus the head weight</li> <li>Set the distance with the head id index equal to the distance with u index plus the head weight</li> <li>Set the previous distance list with the head id index to u</li> <li>Add head item to the queue</li> </ul> </li> <li>Set head to the next item</li> </ul> </li> <li>Check if end vertex was reached</li> <li>If distance with end vertex index is not equal to a maximum integer, return that value from the distances array</li> <li>Default to return to 0 if the above steps don't work</li> </ul>"},{"location":"graph-algorithms/pathfinding/#random-walk","title":"Random Walk","text":"<ul> <li>Grab the head node of the graph using start vertex as index</li> <li>Initialize a random seed</li> <li>Iterate through graph for n steps<ul> <li>Initalize array of neighbors - array is set to size of graph</li> <li>Intitialize a counter variable</li> </ul> </li> </ul>"},{"location":"graph-algorithms/pathfinding/#dijkstra","title":"Dijkstra","text":"<ul> <li>Grab node with start vertex from adjacency list</li> <li>Allocate slots for storing previous nodes and distances for each node</li> <li>Create a queue to store all nodes from graph</li> <li>Set all vertices except the start vertex to the max integer</li> <li>Push start vertex to the front of the queue</li> <li>Distance for start vertex should be set to 0</li> <li>Go through all nodes in the queue</li> <li>Get the minimum distance and compare distance for head node and current</li> <li>Push node back to queue</li> <li>Repeat these steps</li> </ul>"},{"location":"graph-algorithms/pathfinding/#bellman-ford","title":"Bellman Ford","text":"<ul> <li>Initiate distances with start vertex and all other nodes in graph</li> <li>Relax all the edges in the graph (Refer to code)</li> <li>Check for negative weight cycles (Refer to code)</li> <li>Return the array of current distances from relax and negative weight cycle step</li> </ul>"},{"location":"graph-algorithms/searching/","title":"Searching","text":"<ul> <li>Optimize algorithms to search graph data structures efficiently</li> <li>Create tools to benchmark searching algorithm performance</li> <li>Invent a searching algorithm</li> </ul>"},{"location":"graph-algorithms/searching/#depth-first-search","title":"Depth First Search","text":"<ul> <li>Grab the root node in the adjacency list</li> <li>Store the root node in a temporary value</li> <li>Push root node to queue (queue is parameter to method)</li> <li>Iterate through the temporary values neighbors</li> <li>If the neighbor has been visited, recursively call the method</li> <li>Return once done</li> </ul>"},{"location":"graph-algorithms/searching/#breath-first-search","title":"Breath First Search","text":"<ul> <li>Initiate 2 queues, one for graph nodes, one for visited nodes</li> <li>Iterate through the queue (while it's not empty)</li> <li>Get current item in the queue</li> <li>Pop element from the queue and add to visited queue</li> <li>Add non visited neighbor nodes to the queue</li> <li>Return results from visited queue results</li> </ul>"},{"location":"graph-algorithms/utilities/","title":"Graph Utilities","text":"<ul> <li>Graph Representation</li> <li>Conversions</li> <li>Data Frame<ul> <li>Data Frame to Unweighted Graph</li> <li>Data Frame to Weighted Graph</li> </ul> </li> <li>General Utilities<ul> <li>Get Unique Nodes</li> <li>Unique Nodes (File Based)</li> <li>Max Vertex Count</li> <li>Clear Unused Slots</li> </ul> </li> <li>Serialization<ul> <li>Serialize Sorted Labels</li> <li>Serialize Weights, ID's</li> <li>De Serialization</li> </ul> </li> </ul>"},{"location":"graph-algorithms/utilities/#graph-representation","title":"Graph Representation","text":"Attribute Name Description Adjacency list Reference to the adjacency list structure Matrix Reference to the matrix structure Map Hash map representation of graph Labels List of labels associated with the corresponding vertices Directed Boolean to say if graphs relationships are directed Vertice Count Amount of nodes in the graph Filename Optional path to a file for graph serializing/deserializing"},{"location":"graph-algorithms/utilities/#conversions","title":"Conversions","text":"<p>Graph Conversions are used to represent a graph in multiple different formats, like an adjacency list or matrix. We also have the option to speciifc whether it's weighted or not.  These are the conversions to support. </p> <ul> <li>Convert a adjacency list to adjacency matrix</li> <li>Convert an non directed, unweighted adjacency list to a non directed, unweighted matrix</li> <li>Convert a directed, unweighted adjacency list to a directed, unweighted matrix</li> <li>Convert a directed, weighted adjacency list to directed, weighted matrix</li> <li>Convert a adjacency matrix to adjacency list</li> <li>Convert an non directed, unweighted adjacency matrix to a non directed, unweighted list</li> <li>Convert a directed, unweighted adjacency matrix to a directed, unweighted list</li> <li>Convert a directed, weighted adjacency matrix to directed, weighted list</li> </ul>"},{"location":"graph-algorithms/utilities/#data-frame","title":"Data Frame","text":"<ul> <li>Methods that use data frames to work with graphs</li> <li>Convert and exchange data between graphs</li> <li>Essential component for getting standard csv data to graphs</li> </ul>"},{"location":"graph-algorithms/utilities/#data-frame-to-unweighted-graph","title":"Data Frame to Unweighted Graph","text":"Parameter Name Type Description <code>frame</code> <code>frame_t</code> Instance of data frame structure <code>cols</code> <code>int*</code> Array of cols to select from <code>size</code> <code>int</code> Size of the column selection <code>directed</code> <code>bool</code> Boolean to set graph to directed <ul> <li>Pass in instance of data frame, selected column indexes, size and boolean for direction</li> <li>Vertex count for graph is based on frame row count times the size specified</li> <li>Create instance of unique set data structure, capacity is the vertex count</li> <li>Validate graph is not weighted, col index length should be even</li> <li>Iterate through items in data frame</li> <li>Grab the src and destination labels and add to unique set data structure instance</li> <li>Look up the src and destination id from the set data structure instance</li> <li>src and dst id's are determined based on the order they come in from the file</li> <li>Add node relationship with source, destination and their respective ID's</li> <li>Return graph instance</li> </ul>"},{"location":"graph-algorithms/utilities/#data-frame-to-weighted-graph","title":"Data Frame to Weighted Graph","text":"Parameter Name Type Description <code>frame</code> <code>frame_t</code> Instance of data frame structure <code>cols</code> <code>int*</code> Array of cols to select from <code>size</code> <code>int</code> Size of the column selection <code>directed</code> <code>bool</code> Boolean to set graph to directed <ul> <li>Pass in instance of data frame, selected column indexes, size and boolean for direction</li> <li>Vertex count for graph is based on frame row count times the size specified</li> <li>Create instance of unique set data structure, capacity is the vertex count</li> <li>Validate graph is not unweighted, col index length should be odd (divisible by 3)</li> <li>Iterate through items in data frame</li> <li>Grab the src,destination labels and add to unique set data structure instance</li> <li>Grab the weight values from the data frame (should be last index in pair of 3)</li> <li>Look up the src ,destination and weight id from the set data structure instance</li> <li>Add node relationship with src, src_id, dst and dst_id</li> <li>Return graph instance</li> </ul>"},{"location":"graph-algorithms/utilities/#general-utilities","title":"General Utilities","text":"<ul> <li>General processes/utilities needed in the graph library</li> <li>Utilities are methods that aren't specific algorithms in graph theory</li> <li>Methods that involve making it easier to work with graph data</li> <li>General utilities should be applicable to multiple representations of a graph </li> </ul>"},{"location":"graph-algorithms/utilities/#get-unique-nodes","title":"Get Unique Nodes","text":"Parameter Name Type Description <code>graph</code> <code>graph_t</code> Instance of graph structure <ul> <li>Supply the graph structure as a parameter</li> <li>Set the capacity of the unique set to be the amount of vertices in the graph</li> <li>Iterate through the nodes and it's neighbors</li> <li>Add each node to a unique set data structure</li> <li>Return the set instance</li> </ul>"},{"location":"graph-algorithms/utilities/#unique-nodes-file-based","title":"Unique Nodes  (File Based)","text":"Parameter Name Type Description <code>filename</code> <code>char*</code> Name of file and path <code>file_size</code> <code>int</code> Buffer size of file <ul> <li>Take in a graph markup language file and expected file buffer size</li> <li>Open file and allocate buffer size </li> <li>Create instance of set data structure with (sorts by character value)</li> <li>Iterate through each line in the file</li> <li>Use regular expression to extract nodes</li> <li>Add each item from regex to unique sorted set data structure</li> <li>Return the instance of the unique set data structure populated</li> </ul>"},{"location":"graph-algorithms/utilities/#max-vertex-count","title":"Max Vertex Count","text":"Parameter Name Type Description <code>filename</code> <code>char*</code> Name of file and path <code>file_size</code> <code>int</code> Buffer size of file <ul> <li>Finds the max vertex count in a markup file based on node id's</li> <li>Supply markup file and buffer size as parameters</li> <li>Assign a variable as max_vertex_count and assign to 0</li> <li>Iterate through each line in the file</li> <li>Extract the node label, id and weight using a regular expression</li> <li>Check if the id is greater or less then the max_vertex_count</li> <li>If the id is greater than the max_vertex_count, set it to the current id</li> <li>Return max vertex count</li> </ul>"},{"location":"graph-algorithms/utilities/#detect-unused-slots","title":"Detect Unused Slots","text":"Parameter Name Type Description <code>graph</code> <code>graph_t</code> Instance of graph structure <ul> <li>Keep track of the last indice that has had neighbors</li> <li>Iterate from the last node id in the graph backwards</li> <li>If a node is used, set the last used indice to that current node</li> <li>Calculate and store the remainder</li> <li>Remainder is the amount of vertices minus the last used indice</li> <li>Store the new size as the vertice subtracted from the remainder</li> <li>Resize the adjacency list (only supported method for now)</li> <li>Return true for indication of success</li> </ul>"},{"location":"graph-algorithms/utilities/#serialization","title":"Serialization","text":"<ul> <li>Methods that work with graph markup files</li> <li>Serialize and de serialize content from in memory graphs</li> <li>Create configuration files for graph unit tests</li> </ul>"},{"location":"graph-algorithms/utilities/#graph-markup-serialization-sorted-labels","title":"Graph Markup Serialization ( Sorted Labels)","text":"<ul> <li>Supply in file name and selected file buffer size</li> <li>File name only takes in string values as nodes and neighbors</li> <li>Call get unique graph nodes (file based method), store in set data structure</li> <li>Create graph instance and vertex count is the count of the set data structure</li> <li>Iterate through each line in the file</li> <li>Extract node and it's neighbors using the regular expression</li> <li>Get the src, src_id, dst, dst_id using the get_value id method from the set data structure</li> <li>Add the src to dst using all the fields to the graph</li> <li>return the graph data structure instance</li> </ul>"},{"location":"graph-algorithms/utilities/#graph-markup-serialization-weights-id","title":"Graph Markup Serialization (Weights, ID)","text":"<ul> <li>Supply in file name and selected buffer size</li> <li>Markup files takes in labels, id's and weights.</li> <li>Id's in markup file must be in incremental order and cannot exceed vertex count</li> <li>Call method to find max vertex count by scanning all graph node id's</li> <li>Create graph instance and supply a vertex count (based on max vertex count)</li> <li>Iterate through each line of the markup file</li> <li>Extract node id, label and weight and it's neighbors using regular expression</li> <li>Grab id, label and weight for source destination, extract from tokens in regular expression</li> <li>Add the node relationship using all the attributes</li> <li>return the graph data structure instance</li> </ul>"},{"location":"graph-algorithms/utilities/#graph-markup-de-serialization","title":"Graph Markup De Serialization","text":"<ul> <li>Supply in graph instance and filename to export to</li> <li>Open file and allocate expected file size</li> <li>Iterate through graph instance's nodes and neighbors</li> <li>Check if there are quotes in the label nodes or neighbors and remove them</li> <li>Format string for graphs node and it's neighbor</li> <li>Write format string to file and proceed to next line</li> <li>Return file instance when done</li> </ul>"}]}